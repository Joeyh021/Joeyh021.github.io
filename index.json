[{"content":"Rust on embedded devices is great.\nIt makes perfect sense, because embedded software often needs to be bulletproof and Rust can do that while still providing the performance and low-level control that you need from a systems programming language. C and C++ have kind of been the only option for embedded for far too long now, and it\u0026rsquo;s great that there is finally an alternative to segfaults and memory CVEs for embedded developers. I don\u0026rsquo;t have half as much experience with embedded systems as I\u0026rsquo;d like, but I\u0026rsquo;ve played around with Arduino and Raspberry Pi stuff in the past. It\u0026rsquo;s one of those things where I always want to learn/do more, but anything substantial requires hardware and time, two things that I don\u0026rsquo;t have much of.\nI\u0026rsquo;d bought an Arduino Nano 33 IoT, with grand intentions of Yet Another Project which never came to fruition properly. I only really got as far as flashing some Rust code onto it, and using it to blink LEDs and read a few button presses. This was still cool though, because I learned a lot about the whole embedded ecosystem in Rust along the way.\nSo, when UWCS were looking for people to give talks, I thought I might as well take the opportunity do a little Rust evangelism, and also talk a bit about bare metal programming. The whole idea was to introduce Rust, how it works in the embedded domain, and show off the classic LED blinky example. This blog post is an accompaniment to that talk I gave (6 months ago now (I\u0026rsquo;ve been busy, okay)). It\u0026rsquo;s on Youtube, and personally, I think it\u0026rsquo;s worth the watch.\nEmbedded Rust # Embedded is a big target for the Rust project, and there is an excellent community working hard to make Rust run on as many things as possible. Microarchitecture crates and peripheral access crates (PACs) provide access to the low-level peripherals in a microcontroller, and then Hardware Abstraction Layers (HALs) provide a, device-agnostic, type-safe, idiomatic, Rusty API over it all. The Embedded HAL crate provides a set of traits that device-specific HALs then implement. The idea is that people write drivers generic over the traits, and any device that implements the HAL traits can work with the driver.\nFor example, there\u0026rsquo;s a trait to represent a digital output pin which a new microcontroller could implement for its own output pins. Any pre-existing device drivers that use digital output pins would then work for this microcontroller. Traits, Abstraction, Polymorphism. Great stuff.\nDo you have a moment to talk about our Lord and Saviour, Ferris? My Arduino is an ATSAMD21G, a neat little 32-bit ARM Cortex-M0+ device with 256kB of flash memory, and 32kB of SRAM, all operating at a blazing-fast 48 MHz.\nThe atsamd-rs repo provides me with a PAC, HAL, and specific board support crate (BSP) for my board with MCU pins mapped to physical board pins, which made it easy to get started (especially because the blinky example in the repo is also the exact thing I used as a demo).\nMy little Arduino and its terrible soldering job However, it must be noted that the ecosystem is still young and there isn\u0026rsquo;t support out there for all devices yet. I chose this board because I knew ARM architectures had good support in Rust and that there was crates out there for it already. As an example, Rust doesn\u0026rsquo;t support Espressif\u0026rsquo;s Xtensa-based ESP32 and ESP8266 chips, and there\u0026rsquo;s custom forks of both LLVM and Rust that have to be used to work with those. It\u0026rsquo;s also often the case that there\u0026rsquo;s no PAC/HAL/BSP for a board you want to use, in which case you\u0026rsquo;re stuck having to make your own with whatever is already out there. BSPs build on HALs build on PACs, so your mileage with existing support can vary.\nBare Metal # Writing Rust for microcontrollers means you\u0026rsquo;re running in a bare-metal environment: no operating system. Your code is the only thing running on that CPU, which means theres a few things to consider:\nYou can\u0026rsquo;t link to Rust\u0026rsquo;s standard library, because much of the code there assumes the presence of an operating system, a luxury we do not have in this case. The #![no_std] attribute tells the compiler not to link the std crate in. You need a panic handler to tell Rust what to do in case of a panic. Without the standard library, this behaviour must be defined explicitly. The cortex_m_rt crate provides minimal startup code and a runtime for ARM Cortex-based devices, which is linked in by including it in the package manifest. It takes care of few micro-architecture specific things, such as declaring the entry point of the program and populating the device\u0026rsquo;s vector table. You need to cross-compile for the target architecture, which is done by specifying the Arduino\u0026rsquo;s target triple (thumbv6m-none-eabi) in .cargo/config. Having to deal with all this would usually be deemed a faff, and rightfully so, but it\u0026rsquo;s interesting to me: it\u0026rsquo;s the kind of code I enjoy writing and it appeals to the engineer in me. Working directly on the metal exposes a bunch of interesting details about how CPUs and computer systems actually work, making you take care of all the things that most programmers can 99% of the time take for granted, and giving you a deeper understanding of the usually invisible details. Systems programming is cool ðŸ˜Ž\nBlinky # One Github repo later, and the LED I wired up (electronics engineer btw) to pin 10 is blinking. Riveting stuff.\nI love it when my LED turns off and then on again every 200 milliseconds. You can watch the video if you want a full walkthrough of the code and how it all works (except for the bit at the end where it doesn\u0026rsquo;t work because I missed a line from my linker script and forgot to declare one of my variables mutable (the old curse of live demos)), but I wanted to talk in more detail about some bits I found interesting.\nPanics # Rust has certain symbols which must exist in binaries, known as lang items. Usually you needn\u0026rsquo;t worry about these, but there\u0026rsquo;s some that are defined in the standard library, most notably panic_impl, that the compiler won\u0026rsquo;t compile without. We need our own panic handler, which we use from the panic_halt crate. It contains a single function marked with the #[panic_handler] attribute:\n#[panic_handler] fn panic(_info: \u0026amp;PanicInfo) -\u0026gt; ! { loop { atomic::compiler_fence(Ordering::SeqCst); } } The functions take a reference to a PanicInfo struct (because it has to), and then just loops infinitely. The atomic::compiler_fence(Ordering::SeqCst) call tells the compiler that all code after it must obey sequential consistency rules, which stops the compiler doing any reordering of instructions after this function is called, because it would be bad if something was reordered to execute after our panic handler.\nThe line use panic_halt as _ puts the function into the program, but since it is never called or interacted with manually, it\u0026rsquo;s not bound to a name. It\u0026rsquo;s just there, lurking in the binary to take care of things when I inevitably fuck up.\nLinkers # Linker scripts are something else we need to get into that aren\u0026rsquo;t usually an issue. In .cargo/config.toml, we specify two rustc arguments:\nlink-arg=-Tlink.x tells the linker to use the link.x script included with cortex_m_rt, which ensures that our program has all the right sections in its binary and is laid out in memory correctly for the Cortex-M architecture. link-arg=-nmagic tells the linker explicitly to disable page alignment of output sections. There\u0026rsquo;s nothing as fancy as memory paging going on on this little Arduino, and the linker trying to align things to page boundaries moves sections in a way that confuses some flashing tools. Which is bad, because you could accidentally end up overwriting the Arduino\u0026rsquo;s bootloader. Very bad. There\u0026rsquo;s a simple linker script memory.x in the root of the cargo project too that\u0026rsquo;s specific to our board and describes its address space:\nMEMORY { FLASH (rx) : ORIGIN = 0x00000000+0x2000, LENGTH = 0x00040000-0x2000 /* bootloader 8kb */ RAM (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } We\u0026rsquo;re telling the linker that the board\u0026rsquo;s flash is read and execute only (rx permissions), starts at 0x200, and is 0x40000 (256kB) long. The 8kB offset is to account for the bootloader that we, again, do not want to overwrite. The RAM starts at address 0x20000000 and is 32kB long, with rwx permissions (because that\u0026rsquo;s what RAM is for).\nPeripherals and Ownership # Rust doesn\u0026rsquo;t like global mutable state (for obvious reasons), so working with peripherals in embedded systems i.e., one big global mutable state, is an interesting problem to model. The Embedded Book does a better job of explaining this than I will, but the idea is that peripherals are singletons. Only one instance of a singleton peripheral type can exist at any time, and that you must have ownership of a peripheral to work with it.\nThe distinction Rust provides at compile time between mutable and immutable state keeps track of what registers are changing and what peripherals are modifying which values, and allows the compiler reason about what you\u0026rsquo;re doing with your hardware. The state and configuration of peripheral interfaces can also be modelled on the type level to guarantee safety, that you aren\u0026rsquo;t doing something silly like reading from an output pin. These kind of static guarantees don\u0026rsquo;t exist in C/C++, and remove most of the common foot-guns you find in embedded programming, making your life much easier (in return for having to deal with the borrow checker, that is).\nIf you look at the example code, there\u0026rsquo;s a bunch of let bindings in main that just seem like dumb boilerplate, but they\u0026rsquo;re actually really important because we\u0026rsquo;re taking ownership of and initialising all the peripherals that the program needs to blink the LED.\nConclusion # I hope you enjoyed my ramblings on my brief misadventures into embedded Rust. I hope that I\u0026rsquo;ll eventually get round to doing something substantial and (maybe even cool) with in in future. If you want to read more, the Embedded and Discovery books are both excellent to work through. As always, the best way to get the hang of something is to try it, so pick up a board and blink some LEDs on it. It\u0026rsquo;s way more exciting than it sounds, I promise.\n","date":"7 April 2022","permalink":"/blog/rust_arduino/","section":"Blog","summary":"Who knew how exciting blinking LEDs could be?","title":"A Foray Into Embedded Rust"},{"content":"In case anyone else happens to be interested in what I\u0026rsquo;m interested in.\n","date":"7 April 2022","permalink":"/blog/","section":"Blog","summary":"In case anyone else happens to be interested in what I\u0026rsquo;m interested in.","title":"Blog"},{"content":"","date":"7 April 2022","permalink":"/","section":"joeyh.dev","summary":"","title":"joeyh.dev"},{"content":"I bought this domain a year ago today, with grand visions of writing interesting blog posts and whatever other cool shit it is people do with domains. Unfortunately all that ever happened was I threw together the crappiest HTML/CSS homepage ever (not a web dev btw), and used it to point to my notes. Inspired by the 15 quid I had to shell out to renew it, that has changed with a shiny new website and actual blog. Big things coming.\n","date":"6 April 2022","permalink":"/blog/on_blogging/","section":"Blog","summary":"Doing something for once, hopefully","title":"On Blogging"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]