[{"content":"In case anyone else happens to be interested in what I\u0026rsquo;m interested in.\n","date":"31 July 2022","permalink":"/blog/","section":"Blog","summary":"In case anyone else happens to be interested in what I\u0026rsquo;m interested in.","title":"Blog"},{"content":"","date":"31 July 2022","permalink":"/","section":"joeyh.dev","summary":"","title":"joeyh.dev"},{"content":"The title of my third year project is \u0026ldquo;Programmable I/O for Flexible Interfaces in Embedded RISC-V Systems\u0026rdquo;, which basically just means making something very similar to the Programmable I/O blocks on the Raspberry Pi Pico (which I think are insanely cool), and then integrating them with a RISC-V core to create a simple microcontroller that can interface with basically anything at fairly low power. This means a lot of work with FPGAs and Verilog/HDL which are two things I don\u0026rsquo;t have much experience with.\nI did do an introductory digital systems design course as part of my degree last year, and learned a bit about Verilog and FPGA design \u0026amp; architecture. The coursework was making a video game (a very common application for FPGAs, of course), and our shitty asteroids clone was mostly thrown together in one very long week of late nights spent fighting with Xilinx Vivado, the FPGA IDE and toolchain, and also perhaps the worst piece of software ever. However, going from making an arcade game to a microcontroller is a big leap that\u0026rsquo;s going to require a lot of learning.\nSo instead of revising for my exams, I spent a few days trying to get to grips better with Xilinx\u0026rsquo;s design tools and FPGA work in general by designing a hardware interface for a seven segment display, integrating it with an existing RISC-V core, and then writing a software driver for it in Rust.\nI taught a computer to count! Getting Going # My staring point was this GitHub repo, which was basically perfect because it provides a RISC-V SoC with UART, Ethernet, an SD card controller, and scripts to build bootloaders and the Linux kernel. It was literally as easy running make as per the instructions, flashing the kernel onto an SD card, and then connecting over the serial port. I had Debian up and running on the Nexys A7 board the School of Engineering had kindly let me borrow with surprisingly little difficulty. The Vivado block design of the SoC is shown below, it\u0026rsquo;s just a core hooked up to the onboard DDR2 memory and a few I/O components using AXI buses.\nThe SoC, as seen in Vivado. Expand the image to see in more detail. The CPU core used is Rocket Chip, an open-source RISC-V SoC generator built and maintained by UC Berkeley Architecture Research. Rocket Chip can generate a RTL RISC-V implementation that has virtual memory, a coherent multi-level cache hierarchy, IEEE-compliant floating-point units, and all the other bits and bobs you need for a useful CPU. All the HDL is entirely parametrised, so can be customised to generate whatever kind of core takes your fancy. It\u0026rsquo;s written in CHISEL, a HDL embedded in Scala, which is what enables this. Scala for HDL sounds cool (read: better than Verilog, which is not much competition), and I really want to try it out at some point.\nLinux running on an FPGA was cool, but I didn\u0026rsquo;t do much with it besides brag about it on IRC.\nYes, it\u0026rsquo;s technically discord, we have a chat bridge. Instead, I went back and compiled the bare metal example because Linux was super slow, and writing bare metal drivers is much simpler than Linux drivers (part 2, perhaps?). The example is just sending hello world over the serial port by writing to the UART registers, but the key bit is the linker script and startup code, which will come in handy later. The more observant among you will notice one problem with this code though\u0026hellip;\nCrab Time # It\u0026rsquo;s written in C, so obviously it needed the Rewrite It In Rust treatment. My idea was to create a minimal no-std executable using the riscv-rt crate, which is meant to provide a startup and runtime for embedded RISC-V targets. Of course, it couldn\u0026rsquo;t be that simple, and I ended up spending the best part of a day grappling with rustc/lld to generate me an executable that would run, all to no avail. I probably tried every command line flag and cargo configuration parameter in existence, but could not for the life of me get anything to work using riscv-rt . My hacky solution in the end was to just compile a rust crate without riscv-rt to a static library exposing only main, and then invoke the GCC cross-compiler to link using the linker script and startup assembly code from the example. This worked without any trouble, and I had Rust code running on an FPGA!\nAt least the serial interface works. The serial interface code is shown below. The hardware has 4 registers: Rx, Tx, and control and status registers. I can\u0026rsquo;t find much documentation on how to use the control/status registers besides the example code, but the idea is simple enough: put some bytes in the Tx register, and it gets sent to the console on the other end.\npub struct Serial(\u0026amp;\u0026#39;static mut UartRegs); #[repr(C)] struct UartRegs { rx_fifo: RO\u0026lt;u32\u0026gt;, tx_fifo: WO\u0026lt;u32\u0026gt;, status: RO\u0026lt;u32\u0026gt;, control: RW\u0026lt;u32\u0026gt;, } impl Serial { pub unsafe fn new() -\u0026gt; Self { Serial((UART_ADDR as *mut UartRegs).as_mut().unwrap()) } pub fn write_byte(\u0026amp;mut self, byte: u8) { while (self.0.status.read() \u0026amp; SR_TX_FIFO_FULL) != 0 {} unsafe { self.0.tx_fifo.write(byte as u32) } } } I\u0026rsquo;m using volatile_register, which provides read-only, write-only and read-write cells with volalile access for modelling CPU registers. Rust really shines here, as I can encode what functions are read-only and what requires a write in the type system, and through the use of immutable vs mutable references. Writes are also effectful, so require unsafe blocks, whereas reads do not. The #[repr(C)] is needed as Rust makes no guarantees on struct layout, so we need to tell the compiler to lay the data out in the way C would (which is the way you would expect) to be able to just cast our address to a *mut UartRegs and it work.\nThe Display Controller # So I had the bare minimum working, it was time to extend it with something a little more exciting. The 7 segment display on my board has a hardware interface that looks like the following:\nA 4-digit 7 segment display module (of which this board has two) Each digit has it\u0026rsquo;s own common anode, and all the same segments on each digit share a pin. This means it\u0026rsquo;s fairly easy to write a controller which controls all the digits in unison: tie all the anodes high, and then work out what patterns of segment signals correspond to each digit. In Verilog, that\u0026rsquo;s a simple behavioural case statement:\nalways@* begin case (number) // lots of bit patterns 4\u0026#39;h0: digit = 7\u0026#39;b1111110; 4\u0026#39;h1: digit = 7\u0026#39;b0110000; 4\u0026#39;h2: digit = 7\u0026#39;b1101101; 4\u0026#39;h3: digit = 7\u0026#39;b1111001; 4\u0026#39;h4: digit = 7\u0026#39;b0110011; 4\u0026#39;h5: digit = 7\u0026#39;b1011011; 4\u0026#39;h6: digit = 7\u0026#39;b1011111; 4\u0026#39;h7: digit = 7\u0026#39;b1110000; 4\u0026#39;h8: digit = 7\u0026#39;b1111111; 4\u0026#39;h9: digit = 7\u0026#39;b1111011; 4\u0026#39;ha: digit = 7\u0026#39;b1110111; 4\u0026#39;hb: digit = 7\u0026#39;b0011111; 4\u0026#39;hc: digit = 7\u0026#39;b1001110; 4\u0026#39;hd: digit = 7\u0026#39;b0111101; 4\u0026#39;he: digit = 7\u0026#39;b1001111; 4\u0026#39;hf: digit = 7\u0026#39;b1000111; endcase end Controlling each digit individually is a bit harder, as the segments are all connected together. The way to do it is to strobe the anodes, having only one of them active at a time and displaying the segment pattern that we want, but strobe it fast enough that our eyes can\u0026rsquo;t tell that only one digit is on at a time. The onboard clock is 100MHz, so we use a 20-bit counter to slow that down to a much more tame ~100Hz, and select which of the 8 digits is active.\n//divide the 100mhz clock to something a little slower reg [19:0] clk_count = 20\u0026#39;d0; always @ (posedge clk) clk_count \u0026lt;= clk_count + 1\u0026#39;b1; //use most significant 3 bits to count which LED is active wire [2:0] active_digit = clk_count[19:17]; For those of you not familiar with verilog:\nreg [19:0] defines a register that is 20 bits wide 20'd0 is a numeric literal that is 20 bits wide, specified in decimal, with the value 0 Yes, really, that\u0026rsquo;s the syntax. always @ (posedge clk) defines a circuit that is rising edge-triggered \u0026lt;= is non-blocking register assignment clk_count[19:17] is a bitwise slice of the most significant 3 bits of the register clk_count Rather counterintuitively, the anodes and digits are both active low. I didn\u0026rsquo;t figure this out until I\u0026rsquo;d spent an entire weekend debugging everything instead of just reading the docs ðŸ™ƒ.\nWriting a simple verilog module to act as a controller was the easy part, integrating it with the existing SoC was the challenge. All the other I/O blocks are connected over an AXI4 bus, which is fairly simple to extend. AXI-4 is a bus interface specification developed by ARM as part of the AMBA (Advanced Microcontroller Bus Architecture) specification, it\u0026rsquo;s a transaction-oriented master-slave interface with 5 channels. There are 3 types of AXI-4 interface:\nFull AXI, for high performance memory mapped I/O AXI-Lite for simpler, low throughput memory mapped registers AXI-Stream, for high speed streaming data The AXI Interface (image from Xilinx) I went with AXI Lite, as all I was connecting was 8 registers (one for each digit). Vivado includes a \u0026ldquo;wizard\u0026rdquo; to generate a template for an AXI IP block, so it created a new project for me with a top level module defining an AXI interface, and very kindly pointed out where to insert my own port and module instantiations. I instantiated my module and connected the bus registers to the display controller, and then added two new output ports to the block, anode[7:0] for the 8 anodes and seg[6:0] for the 7 segments.\nMy very own IP core! (The three input ports are clock, reset, and the AXI bus connection, which Vivado handles all the internal wires for.)\nAdding my new IP to the design was relatively painless, just a few steps in the block diagram GUI to drop it in and connect the wires up. I had to also extend the I/O address space to memory-map my registers, and add a new constraints file to connect the output from the design to the peripherals. Constraints files contain information about the physical properties of the design (clocks, I/O, timing), and in this case they\u0026rsquo;re used to connect the right wires on the design to the correct physical output pins on the FPGA chip.\nTo verify this worked I used Xilinx System Debugger (xsdb) to connect to the FPGA, which provides a neat little command line interface where you can poke and prod at running targets on an FPGA or Xilinx SoC. I manually wrote into the address I\u0026rsquo;d mapped the registers to to verify that everything worked, which it did (after I remembered that the anodes were active low and fixed that).\nMore Rust # So the hardware works, but what about software? Writing a driver for the display device was fairly simple, just define an array of 8 registers and wrap it in a struct, and we can use the same pointer-cast technique from earlier to create the device.\ntype DigitRegs = [RW\u0026lt;u32\u0026gt;; 8]; #[repr(C)] pub struct Display(\u0026amp;\u0026#39;static mut DigitRegs); impl Display { pub unsafe fn new() -\u0026gt; Self { Display((DISPLAY_ADDR as *mut DigitRegs).as_mut().unwrap()) } pub fn take() -\u0026gt; Option\u0026lt;Self\u0026gt; { singleton!(:\u0026amp;\u0026#39;static mut DigitRegs = unsafe { (DISPLAY_ADDR as *mut DigitRegs).as_mut()? }) .map(|regs| Display(regs)) } } The intended way to get an instance of the struct is through the take method. It makes use of the singleton! macro from the riscv architecture crate, that will return a Some(T) the first time it is called, but a None every time after that. This ensures that we only have one instance of our peripheral struct, which prevents multiple concurrent accesses leading to race conditions, etc. We use it to create a \u0026amp;'static mut DigitRegs from a pointer to the address where they are, and then wrap that in a struct to create the display device. It\u0026rsquo;s a neat little bit of unsafe rust, and we\u0026rsquo;re still trying to use the type system to our advantage to enforce safety.\nI wanted to implement the Index and IndexMut traits for Display, but this turned out to not be possible. The Index trait looks like this (slightly simplified, and with lifetime annotations added):\npub trait Index\u0026lt;Idx\u0026gt;{ type Output; fn index\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;\u0026#39;a self, index: Idx) -\u0026gt; \u0026amp;\u0026#39;a Self::Output; } Index has to return a reference, the lifetime of which is the same as the lifetime of self. In this case, that would be 'static. However, under the hood, our data is accessed using ptr::volatile_read, which returns T, not \u0026amp;T or \u0026amp;mut T. We can\u0026rsquo;t actually get a reference to the data in our registers safely, so we can\u0026rsquo;t satisfy the requirements for Index. Or IndexMut. Instead, I settled for boring old fn get(\u0026amp;self, idx: usize) -\u0026gt; u32 and fn set(\u0026amp;mut self, idx: usize, val: u32).\nWith the API all set up, I wrote a little demo program that rotated the digits 0-9 across the display, which is what\u0026rsquo;s running in the gif from further up.\n//init the 8 digits for i in (0..8).rev() { display.set(i, i as u32); } loop { //shift all the digits along for i in (1..8).rev() { display.set(i, display.get(i - 1)); } //set the last digit to 1+ the prev value display.set(0, (display.get(0) + 1) % 10); //write the digits to the serial device too for i in 0..8 { serial.write_byte(display.get(i) as u8 + 48); serial.print(\u0026#34; \u0026#34;); } serial.println(\u0026#34;\u0026#34;); delay.delay_ms(1000); } Conclusion # This was a really fun little project, getting to play around with loads of different aspects of embedded and digital systems design that I\u0026rsquo;m interested in, and that I\u0026rsquo;m going to be doing more of next year. There was a lot of trial and error, poring over Xilinx documentation, and fighting Vivado (when it wasn\u0026rsquo;t crashing), but its those kinds of experiences where you often end up learning the most. It really didn\u0026rsquo;t come together anywhere near as cleanly as I\u0026rsquo;ve probably made out.\nThere\u0026rsquo;s a lot more I want to explore too. CHISEL seems super interesting, I like the idea of using a functional language to build circuits (with an actual type system to enforce design constraints). I also barely scratched the surface with AXI, and Vivado did most of the work for me: I\u0026rsquo;ll need to be a lot more familiar with it for designing more complex I/O devices, especially AXI-Stream for the kind of high throughput design I have in mind.\nI also want to thank Eugene Tarassov for the GitHub repo that provided the block design and scripts for the RISC-V SoC. I wouldn\u0026rsquo;t have had a clue where to even start without that, and it will probably end up being the starting point for my actual project\n","date":"31 July 2022","permalink":"/blog/fpga-seven-segment/","section":"Blog","summary":"Getting my feet wet with FPGA design","title":"Rust, FPGAs, and Seven Segment Displays"},{"content":"Rust on embedded devices is great.\nIt makes perfect sense, because embedded software often needs to be bulletproof and Rust can do that while still providing the performance and low-level control that you need from a systems programming language. C and C++ have kind of been the only option for embedded for far too long now, and it\u0026rsquo;s great that there is finally an alternative to segfaults and memory CVEs for embedded developers. I don\u0026rsquo;t have half as much experience with embedded systems as I\u0026rsquo;d like, but I\u0026rsquo;ve played around with Arduino and Raspberry Pi stuff in the past. It\u0026rsquo;s one of those things where I always want to learn/do more, but anything substantial requires hardware and time, two things that I don\u0026rsquo;t have much of.\nI\u0026rsquo;d bought an Arduino Nano 33 IoT, with grand intentions of Yet Another Project which never came to fruition properly. I only really got as far as flashing some Rust code onto it, and using it to blink LEDs and read a few button presses. This was still cool though, because I learned a lot about the whole embedded ecosystem in Rust along the way.\nSo, when UWCS were looking for people to give talks, I thought I might as well take the opportunity do a little Rust evangelism, and also talk a bit about bare metal programming. The whole idea was to introduce Rust, how it works in the embedded domain, and show off the classic LED blinky example. This blog post is an accompaniment to that talk I gave (6 months ago now (I\u0026rsquo;ve been busy, okay)). It\u0026rsquo;s on Youtube, and personally, I think it\u0026rsquo;s worth the watch.\nEmbedded Rust # Embedded is a big target for the Rust project, and there is an excellent community working hard to make Rust run on as many things as possible. Microarchitecture crates and peripheral access crates (PACs) provide access to the low-level peripherals in a microcontroller, and then Hardware Abstraction Layers (HALs) provide a, device-agnostic, type-safe, idiomatic, Rusty API over it all. The Embedded HAL crate provides a set of traits that device-specific HALs then implement. The idea is that people write drivers generic over the traits, and any device that implements the HAL traits can work with the driver.\nFor example, there\u0026rsquo;s a trait to represent a digital output pin which a new microcontroller could implement for its own output pins. Any pre-existing device drivers that use digital output pins would then work for this microcontroller. Traits, Abstraction, Polymorphism. Great stuff.\nDo you have a moment to talk about our Lord and Saviour, Ferris? My Arduino is an ATSAMD21G, a neat little 32-bit ARM Cortex-M0+ device with 256kB of flash memory, and 32kB of SRAM, all operating at a blazing-fast 48 MHz.\nThe atsamd-rs repo provides me with a PAC, HAL, and specific board support crate (BSP) for my board with MCU pins mapped to physical board pins, which made it easy to get started (especially because the blinky example in the repo is also the exact thing I used as a demo).\nMy little Arduino and its terrible soldering job However, it must be noted that the ecosystem is still young and there isn\u0026rsquo;t support out there for all devices yet. I chose this board because I knew ARM architectures had good support in Rust and that there was crates out there for it already. As an example, Rust doesn\u0026rsquo;t support Espressif\u0026rsquo;s Xtensa-based ESP32 and ESP8266 chips, and there\u0026rsquo;s custom forks of both LLVM and Rust that have to be used to work with those. It\u0026rsquo;s also often the case that there\u0026rsquo;s no PAC/HAL/BSP for a board you want to use, in which case you\u0026rsquo;re stuck having to make your own with whatever is already out there. BSPs build on HALs build on PACs, so your mileage with existing support can vary.\nBare Metal # Writing Rust for microcontrollers means you\u0026rsquo;re running in a bare-metal environment: no operating system. Your code is the only thing running on that CPU, which means theres a few things to consider:\nYou can\u0026rsquo;t link to Rust\u0026rsquo;s standard library, because much of the code there assumes the presence of an operating system, a luxury we do not have in this case. The #![no_std] attribute tells the compiler not to link the std crate in. You need a panic handler to tell Rust what to do in case of a panic. Without the standard library, this behaviour must be defined explicitly. The cortex_m_rt crate provides minimal startup code and a runtime for ARM Cortex-based devices, which is linked in by including it in the package manifest. It takes care of few micro-architecture specific things, such as declaring the entry point of the program and populating the device\u0026rsquo;s vector table. You need to cross-compile for the target architecture, which is done by specifying the Arduino\u0026rsquo;s target triple (thumbv6m-none-eabi) in .cargo/config. Having to deal with all this would usually be deemed a faff, and rightfully so, but it\u0026rsquo;s interesting to me: it\u0026rsquo;s the kind of code I enjoy writing and it appeals to the engineer in me. Working directly on the metal exposes a bunch of interesting details about how CPUs and computer systems actually work, making you take care of all the things that most programmers can 99% of the time take for granted, and giving you a deeper understanding of the usually invisible details. Systems programming is cool ðŸ˜Ž\nBlinky # One Github repo later, and the LED I wired up (electronics engineer btw) to pin 10 is blinking. Riveting stuff.\nI love it when my LED turns off and then on again every 200 milliseconds. You can watch the video if you want a full walkthrough of the code and how it all works (except for the bit at the end where it doesn\u0026rsquo;t work because I missed a line from my linker script and forgot to declare one of my variables mutable (the old curse of live demos)), but I wanted to talk in more detail about some bits I found interesting.\nPanics # Rust has certain symbols which must exist in binaries, known as lang items. Usually you needn\u0026rsquo;t worry about these, but there\u0026rsquo;s some that are defined in the standard library, most notably panic_impl, that the compiler won\u0026rsquo;t compile without. We need our own panic handler, which we use from the panic_halt crate. It contains a single function marked with the #[panic_handler] attribute:\n#[panic_handler] fn panic(_info: \u0026amp;PanicInfo) -\u0026gt; ! { loop { atomic::compiler_fence(Ordering::SeqCst); } } The functions take a reference to a PanicInfo struct (because it has to), and then just loops infinitely. The atomic::compiler_fence(Ordering::SeqCst) call tells the compiler that all code after it must obey sequential consistency rules, which stops the compiler doing any reordering of instructions after this function is called, because it would be bad if something was reordered to execute after our panic handler.\nThe line use panic_halt as _ puts the function into the program, but since it is never called or interacted with manually, it\u0026rsquo;s not bound to a name. It\u0026rsquo;s just there, lurking in the binary to take care of things when I inevitably fuck up.\nLinkers # Linker scripts are something else we need to get into that aren\u0026rsquo;t usually an issue. In .cargo/config.toml, we specify two rustc arguments:\nlink-arg=-Tlink.x tells the linker to use the link.x script included with cortex_m_rt, which ensures that our program has all the right sections in its binary and is laid out in memory correctly for the Cortex-M architecture. link-arg=-nmagic tells the linker explicitly to disable page alignment of output sections. There\u0026rsquo;s nothing as fancy as memory paging going on on this little Arduino, and the linker trying to align things to page boundaries moves sections in a way that confuses some flashing tools. Which is bad, because you could accidentally end up overwriting the Arduino\u0026rsquo;s bootloader. Very bad. There\u0026rsquo;s a simple linker script memory.x in the root of the cargo project too that\u0026rsquo;s specific to our board and describes its address space:\nMEMORY { FLASH (rx) : ORIGIN = 0x00000000+0x2000, LENGTH = 0x00040000-0x2000 /* bootloader 8kb */ RAM (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } We\u0026rsquo;re telling the linker that the board\u0026rsquo;s flash is read and execute only (rx permissions), starts at 0x200, and is 0x40000 (256kB) long. The 8kB offset is to account for the bootloader that we, again, do not want to overwrite. The RAM starts at address 0x20000000 and is 32kB long, with rwx permissions (because that\u0026rsquo;s what RAM is for).\nPeripherals and Ownership # Rust doesn\u0026rsquo;t like global mutable state (for obvious reasons), so working with peripherals in embedded systems i.e., one big global mutable state, is an interesting problem to model. The Embedded Book does a better job of explaining this than I will, but the idea is that peripherals are singletons. Only one instance of a singleton peripheral type can exist at any time, and that you must have ownership of a peripheral to work with it.\nThe distinction Rust provides at compile time between mutable and immutable state keeps track of what registers are changing and what peripherals are modifying which values, and allows the compiler reason about what you\u0026rsquo;re doing with your hardware. The state and configuration of peripheral interfaces can also be modelled on the type level to guarantee safety, that you aren\u0026rsquo;t doing something silly like reading from an output pin. These kind of static guarantees don\u0026rsquo;t exist in C/C++, and remove most of the common foot-guns you find in embedded programming, making your life much easier (in return for having to deal with the borrow checker, that is).\nIf you look at the example code, there\u0026rsquo;s a bunch of let bindings in main that just seem like dumb boilerplate, but they\u0026rsquo;re actually really important because we\u0026rsquo;re taking ownership of and initialising all the peripherals that the program needs to blink the LED.\nConclusion # I hope you enjoyed my ramblings on my brief misadventures into embedded Rust. I hope that I\u0026rsquo;ll eventually get round to doing something substantial and (maybe even cool) with in in future. If you want to read more, the Embedded and Discovery books are both excellent to work through. As always, the best way to get the hang of something is to try it, so pick up a board and blink some LEDs on it. It\u0026rsquo;s way more exciting than it sounds, I promise.\n","date":"7 April 2022","permalink":"/blog/rust_arduino/","section":"Blog","summary":"Who knew how exciting blinking LEDs could be?","title":"A Foray Into Embedded Rust"},{"content":"I bought this domain a year ago today, with grand visions of writing interesting blog posts and whatever other cool shit it is people do with domains. Unfortunately all that ever happened was I threw together the crappiest HTML/CSS homepage ever (not a web dev btw), and used it to point to my notes. Inspired by the 15 quid I had to shell out to renew it, that has changed with a shiny new website and actual blog. Big things coming.\n","date":"6 April 2022","permalink":"/blog/on_blogging/","section":"Blog","summary":"Doing something for once, hopefully","title":"On Blogging"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]